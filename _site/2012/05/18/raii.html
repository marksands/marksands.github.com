<!DOCTYPE html>
<html class="no-js">
  <head>
	<meta charset="utf-8">
	<title>RAII | Mark Sands</title>
	<meta name="description" content="RAII is Resource Acquisition Is Initialization, and it&#39;s a neat concept once you understand what it means and how it&#39;s used. RAII was born out of C++...">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-Frame-Options" content="sameorigin">

	<!-- CSS -->
	<link rel="stylesheet" href="/css/main.css">

	<!--Favicon-->
	<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

	<!-- Canonical -->
	<link rel="canonical" href="http://marksands.github.io/2012/05/18/raii.html">

	<!-- RSS -->
	<link rel="alternate" type="application/atom+xml" title="Mark Sands" href="http://marksands.github.io/feed.xml" />

	<!-- Font Awesome -->
	<link href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet">

	<!-- Google Fonts -->
	
	<link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700,700italic,400italic" rel="stylesheet" type="text/css">
	

	<!-- KaTeX -->
	

	<!-- Google Analytics -->
	
	<script>
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	ga('create', 'UA-41405801-1', 'auto');
	ga('send', 'pageview');
	</script>
	
</head>

  <body>
    <header class="site-header">
	<div class="branding">
		
		<a href="/">
			<img class="avatar" src="https://secure.gravatar.com/avatar/7a6e4cc366f8f533b056936cf9bcb85d?s=100" alt=""/>
		</a>
		
		<h1 class="site-title">
			<a href="/">Mark Sands</a>
		</h1>
	</div>
	<nav class="site-nav">
		<ul>
			
			
			
			
			<li>
				<a class="page-link" href="/about/">
					About
				</a>
			</li>
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			<!-- Social icons from Font Awesome, if enabled -->
			
<li>
	<a href="http://marksands.github.io/feed.xml" title="Follow RSS feed">
		<i class="fa fa-fw fa-rss"></i>
	</a>
</li>



<li>
	<a href="mailto:marksands07@gmail.com" title="Email">
		<i class="fa fa-fw fa-envelope"></i>
	</a>
</li>













<li>
	<a href="https://github.com/marksands" title="Follow on GitHub">
		<i class="fa fa-fw fa-github"></i>
	</a>
</li>





















<li>
	<a href="https://twitter.com/marksands" title="Follow on Twitter">
		<i class="fa fa-fw fa-twitter"></i>
	</a>
</li>






		</ul>
	</nav>
</header>

    <div class="content">
      <article >
  <header style="background-image: url('/')">
    <h1 class="title">RAII</h1>
    <p class="meta">
    May 18, 2012
    
    </p>
  </header>
  <section class="post-content"><p>RAII is <strong>Resource Acquisition Is Initialization</strong>, and it&#39;s a neat concept once you 
understand what it means and how it&#39;s used. RAII was born out of C++ and invented 
by its creator Bjarne Stroustrup.</p>

<p>In C++, the only code that can be guaranteed to be executed after an exception is 
thrown are the destructors of objects residing on the stack. Resource management 
needs to be tied to the lifespan of suitable objects in order to gain automatic 
allocation and reclamation. Resources are acquired during initialization, and 
guaranteed to be released with the destruction of the same objects.</p>

<!-- more -->

<p>For local objects allocated on the stack, the languages scoping rules ensure that 
the destructor is called when its scope ends. Thus, by putting the resource release 
logic in the destructor, C++&#39;s scoping provides direct support for 
RAII<a href="http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization">¹</a>:</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="cp">#include &lt;iostream&gt;
#include &lt;chrono&gt;
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Timer</span> <span class="p">{</span>
    <span class="n">system_clock</span><span class="o">::</span><span class="n">time_point</span> <span class="n">start</span><span class="p">,</span> <span class="n">finish</span><span class="p">;</span>
    <span class="k">public</span><span class="o">:</span>
    <span class="n">Timer</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">system_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="o">~</span><span class="n">Timer</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">finish</span> <span class="o">=</span> <span class="n">system_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
        <span class="n">nanoseconds</span> <span class="n">ns</span> <span class="o">=</span> <span class="n">finish</span> <span class="o">-</span> <span class="n">start</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Total time: "</span>
            <span class="o">&lt;&lt;</span> <span class="n">ns</span><span class="p">.</span><span class="n">count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">" nanoseconds"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Timer</span> <span class="n">t</span><span class="p">;</span>
    <span class="c1">// some long expensive calculation
</span><span class="p">}</span>
</code></pre></div>
<p>In this snippet, the Timer class demonstrates using RAII to calculate and display
the time it takes for a portion of code to execute. A Timer object, <code>t</code>, is 
initialized in the first line of the main function, which will be used 
to calculate and display the global time the program took to execute. Once some
long, expensive calculation runs, the main program will exit and the Timer object
will display the duration it took for the program to execute. Very handy for performance
debugging.</p>

<h3 id="smart-pointers">Smart Pointers</h3>

<p>Consequently, this is how the C++11 library <code>shared_ptr</code> works. It is a reference
counting smart pointer that shares ownership, so when the last copy of it goes out
of scope it will free the managed object. In case you&#39;re wondering, <code>unique_ptr</code> and 
<code>shared_ptr</code> live in the header <code>&lt;memory&gt;</code>.</p>

<p>A smart pointer is a class that imitates raw pointers by overloading operators.
<code>unique_ptr</code> is powered by rvalue references, a C++11 feature. While it is not copyable,
it is movable. With <code>unique_ptr</code> and <code>shared_ptr</code>, <code>std::move</code> can be used as a 
helper function that moves its resources into a different object. The main difference
between <code>unique_ptr</code> and <code>shared_ptr</code> is that unique_ptr does not have shared-ownership,
meaning there is only one reference available at a time<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf">²</a>:</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">42</span><span class="p">));</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">nullptr</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">p2</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>One useful example of this is the <code>pimpl</code> idiom, where you have a pointer
to some class that implements all of its methods. This is useful for breaking 
out dependencies allowing your program to compile faster.</p>

<p>There is a smarter pointer available called <code>shared_ptr</code>, originally developed
for the Boost library but now part of the C++11 standard. <code>shared_ptr</code> objects 
have shared ownership, meaining the last remaining owner of the pointer is responsible 
for destroying the object, or otherwise releasing the resources associated with 
the stored pointer<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf">³</a>.</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">sp</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">42</span><span class="p">));</span>
  <span class="n">std</span><span class="o">::</span><span class="n">shard_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">sp2</span><span class="p">(</span><span class="n">sp</span><span class="p">);</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">sp</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">sp2</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="references">References</h3>

<ul>
<li><a href="http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization">[1] RAII</a></li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf">[2] unique_ptr/20.7.1</a></li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf">[3] shared_ptr/20.7.2.2</a></li>
</ul>
</section>
</article>

<!-- Post navigation -->

<div id="post-nav">
    
    
    <a id="next-post" href="/2013/05/31/builder-pattern.html">
       <span class="page-title">Builder Pattern</span>
       <span class="nav-label">
        Next <i class="fa fa-chevron-right"></i>
       </span>
     </a>
    
</div>


<!-- Disqus -->

<div class="comments">
  <div id="disqus_thread"></div>
<script type="text/javascript">
	var disqus_shortname = 'marksandsgithub';
	(function() {
		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</div>


    </div>
    


<footer class="site-footer">
	<p class="text">Powered by <a href="http://jekyllrb.com">Jekyll</a>
</p>
</footer>


  </body>
</html>
