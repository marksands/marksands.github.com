<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>Reacting to Reactive Cocoa Part III</title>
        <meta name="viewport" content="width=device-width">

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/css/syntax.css">

        <!-- Custom CSS -->
        <link rel="stylesheet" href="/css/main.css">

    </head>
    <body>

      <div id="page" class="hentry">
        
        <header class="the-header">
          <div class="unit-head">
            <div class="unit-inner unit-head-inner">
              <p class="logo"><a href=""></a></p>
              <nav class="nav-global">
                <ul>
                  <li class="github"><a href="http://github.com/marksands">github</a></li>
                  <li class="twitter"><a href="http://twitter.com/marksands">twitter</a></li>
                </ul>
              </nav>
            </div><!-- unit-inner -->
          </div><!-- unit-head -->
        </header>
        
        <div class="body" role="main">
          
          <!-- begin ads -->
          <article class="unit-article layout-page">
            <div class="unit-inner unit-article-inner">
              <div class="content">
                <div class="bd">
                  <div class="entry-content">
                    <script async src="http://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
                    <ins class="adsbygoogle"
                         style="display:inline-block;width:728px;height:90px"
                         data-ad-client="ca-pub-5267577598224051"
                         data-ad-slot="1897609812"></ins>
                    <script>
                    (adsbygoogle = window.adsbygoogle || []).push({});
                    </script>
                  </div>
                </div>
              </div>
            </div>
          </article>
          <!-- end ads -->
          
          <div class="unit-body">
            <div class="unit-inner unit-body-inner">
              <div class="entry-content">
                <article class="unit-article layout-post">
  <div class="unit-inner unit-article-inner">
    <div class="content">
      <header>
        <div class="unit-head">
          <div class="unit-inner unit-head-inner">
            <!-- <h1 class="h2 entry-title">Reacting to Reactive Cocoa Part III</h1> -->
            
            
          </div><!-- unit-inner -->
        </div><!-- unit-head -->
      </header>

      <div class="bd">
        <div class="entry-content">
          <h1>Reacting to Reactive Cocoa Part III</h1>
          <h3>Asynchronously Loading Images</h3>

<p>One of my first endevours into the realm of expanding my <code>RACObserve</code>-fu was to asynchronously load a <code>UIImage</code> from an image URL that was returned from the movie API in order to populate thumbnails in table view cells. Historically, using <code>AFNetworking</code>&#39;s built-in mechanism or a third party caching library such as <code>SDWebImage</code> would work perfectly fine, but I wanted to stick to my guns and fully gulp the Reactive Cocoa punch that I&#39;ve so graciously poured.</p>

<p>This one was hard. I gave it several attempts before finally coming to a working solution, but I never did find the answer I wanted.</p>

<h3>Attempt 1</h3>

<p>I never got my first attempt at this to work, but I&#39;ll show the broken code nonetheless. I began my endevour by shamelessly stealing a code snippet from a project on GitHub called <a href="https://github.com/ashfurrow/FunctionalReactivePixels/blob/aef9b670ec5f14d496049c9e214f99513ca579df/FRP/FRPPhotoImporter.m#L46-L58">Functional Reactive Pixels</a>. The code snippet is slightly different from what I ended up with, but the overal theme is the same: I create an <code>NSURLRequest</code>, use the <code>rac_sendAsynchronousRequest</code> category method, call <code>reduceEach</code> to deflate the <code>RACTuple</code> into the appropriate parameters, return the <code>NSData</code> from the response, deliver the signal on the main thread, map the <code>NSData</code> again to return the <code>UIImage</code> form of the bytes, and eventually finish with a call to <code>publish</code> and <code>autoconnect</code> (whew!).</p>
<div class="highlight"><pre><code class="language-objective-c" data-lang="objective-c">    <span class="n">RAC</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="n">posterImageView</span><span class="p">,</span> <span class="n">image</span><span class="p">)</span> <span class="o">=</span> <span class="p">[</span><span class="n">RACObserve</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="n">movie</span><span class="p">.</span><span class="n">posterURL</span><span class="p">)</span> <span class="nl">map</span><span class="p">:</span><span class="o">^</span><span class="kt">id</span><span class="p">(</span><span class="kt">id</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
        <span class="bp">NSURLRequest</span> <span class="o">*</span><span class="n">request</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSURLRequest</span> <span class="nl">requestWithURL</span><span class="p">:</span><span class="n">value</span><span class="p">];</span>
        <span class="k">return</span> <span class="p">[[[[[[</span><span class="bp">NSURLConnection</span> <span class="nl">rac_sendAsynchronousRequest</span><span class="p">:</span><span class="n">request</span><span class="p">]</span> <span class="nl">reduceEach</span><span class="p">:</span><span class="o">^</span><span class="kt">id</span><span class="p">(</span><span class="bp">NSURLResponse</span> <span class="o">*</span><span class="n">response</span><span class="p">,</span> <span class="bp">NSData</span> <span class="o">*</span><span class="n">data</span><span class="p">){</span>
            <span class="k">return</span> <span class="n">data</span><span class="p">;</span>
        <span class="p">}]</span> <span class="nl">deliverOn</span><span class="p">:[</span><span class="n">RACScheduler</span> <span class="n">mainThreadScheduler</span><span class="p">]]</span>
                <span class="nl">map</span><span class="p">:</span><span class="o">^</span><span class="kt">id</span><span class="p">(</span><span class="bp">NSData</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="p">[</span><span class="bp">UIImage</span> <span class="nl">imageWithData</span><span class="p">:</span><span class="n">data</span><span class="p">];</span>
                <span class="p">}]</span> <span class="n">publish</span><span class="p">]</span> <span class="n">autoconnect</span><span class="p">];</span>
    <span class="p">}];</span>
</code></pre></div>
<p>All of this made intuitive sense to me, except the final two methods <code>publish</code> and <code>autoconnect</code>. An inspection of <code>publish</code> shows that it wraps a signal into a <code>RACMulticastConnection</code> object, while the <code>autoconnect</code> returns the multicast connection object as a signal. The recurring mystery object that kept creeping up was this <code>RACDisposable</code> object that I hadn&#39;t bothered, at least at this point, to investigate.</p>

<p>Ultimately, this code never worked. Each time it ran, it would crash and throw this exception burried in the giant stack trace (have I mentioned how large the stack traces become when using Reactive Cocoa?):</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">2015-01-07 20:23:12.809 BestMovieDeal[5998:117268] *** Terminating app due to uncaught exception &#39;NSInvalidArgumentException&#39;, reason: &#39;-[RACDynamicSignal size]: unrecognized selector sent to instance 0x7f8ad1c6a180&#39;
</code></pre></div>
<h3>Attempt 2</h3>

<p>My second try was to slim down my first approach, using only what I thought was absolutely necessary to make it work. I removed the final 3 lines of the block and returned the <code>UIImage</code> instead of the <code>NSData</code> object to be mapped over again and then returned as an image. This looked promising, but unfortunately gave me the identical stack trace as the first attempt.</p>
<div class="highlight"><pre><code class="language-objective-c" data-lang="objective-c">    <span class="n">RAC</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="n">posterImageView</span><span class="p">,</span> <span class="n">image</span><span class="p">)</span> <span class="o">=</span> <span class="p">[</span><span class="n">RACObserve</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="n">movie</span><span class="p">.</span><span class="n">posterURL</span><span class="p">)</span> <span class="nl">map</span><span class="p">:</span><span class="o">^</span><span class="kt">id</span><span class="p">(</span><span class="kt">id</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
        <span class="bp">NSURLRequest</span> <span class="o">*</span><span class="n">request</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSURLRequest</span> <span class="nl">requestWithURL</span><span class="p">:</span><span class="n">value</span><span class="p">];</span>
        <span class="k">return</span> <span class="p">[[[</span><span class="bp">NSURLConnection</span> <span class="nl">rac_sendAsynchronousRequest</span><span class="p">:</span><span class="n">request</span><span class="p">]</span>
                    <span class="nl">reduceEach</span><span class="p">:</span><span class="o">^</span><span class="kt">id</span><span class="p">(</span><span class="bp">NSURLResponse</span> <span class="o">*</span><span class="n">response</span><span class="p">,</span> <span class="bp">NSData</span> <span class="o">*</span><span class="n">data</span><span class="p">){</span>
                        <span class="k">return</span> <span class="p">[</span><span class="bp">UIImage</span> <span class="nl">imageWithData</span><span class="p">:</span><span class="n">data</span><span class="p">];</span>
                    <span class="p">}]</span> <span class="nl">deliverOn</span><span class="p">:[</span><span class="n">RACScheduler</span> <span class="n">mainThreadScheduler</span><span class="p">]];</span>
    <span class="p">}];</span>
</code></pre></div>
<p>Something still isn&#39;t right, but it&#39;s very hard to deduce what is wrong. I did see <code>-[UIImageView setImage:] + 316</code> in the stack trace, so I feel like I am on the right track; it just looks like either it&#39;s not an image being set on it or something else is awry. And unfortunately, setting a breakpoint on the line with the statement <code>[UIImage imageWithData:data]</code> never gets called. I gave an amateur shot at some lldb spelunking, but it went much slower than what I was used to and I never got anywhere. The next step is to take some time to learn about the missing pieces and find a working solution.</p>

<h3>Attempt 27</h3>

<p>This time I decided to take a step back. I didn&#39;t <em>need</em> the images to be asynchronously loaded in order to display them. The simplest way that I was sure would work, was to use good ol&#39; <code>+[NSData dataWithContentsOfURL:]</code>. </p>
<div class="highlight"><pre><code class="language-objective-c" data-lang="objective-c"><span class="n">RAC</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="n">posterImageView</span><span class="p">,</span> <span class="n">image</span><span class="p">)</span> <span class="o">=</span> <span class="p">[</span><span class="n">RACObserve</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="n">movie</span><span class="p">.</span><span class="n">posterURL</span><span class="p">)</span> <span class="nl">map</span><span class="p">:</span><span class="o">^</span><span class="kt">id</span><span class="p">(</span><span class="kt">id</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span><span class="bp">UIImage</span> <span class="nl">imageWithData</span><span class="p">:[</span><span class="bp">NSData</span> <span class="nl">dataWithContentsOfURL</span><span class="p">:</span><span class="n">value</span><span class="p">]];</span>
<span class="p">}];</span>
</code></pre></div>
<p>Success! It was, of course, slow, but it worked.</p>

<h3>Attempt 342</h3>

<p>Since I had a synchronous solution, my next attempt was to see if I could turn it into an asynchronous solution. From what I&#39;ve gathered, <code>deliverOn:[RACScheduler scheduler]</code> will create a signal that delivers subsequent events on a background thread, and <code>deliverOn:[RACScheduler mainThreadScheduler]</code> will deliver events on the main thread. In the spirit of Reactive Cocoa, I combined the two and came up with this:</p>
<div class="highlight"><pre><code class="language-objective-c" data-lang="objective-c"><span class="n">RAC</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="n">posterImageView</span><span class="p">,</span> <span class="n">image</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[[[</span><span class="n">RACObserve</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="n">movie</span><span class="p">.</span><span class="n">posterURL</span><span class="p">)</span> <span class="nl">deliverOn</span><span class="p">:[</span><span class="n">RACScheduler</span> <span class="n">scheduler</span><span class="p">]]</span> <span class="nl">map</span><span class="p">:</span><span class="o">^</span><span class="kt">id</span><span class="p">(</span><span class="kt">id</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span><span class="bp">NSData</span> <span class="nl">dataWithContentsOfURL</span><span class="p">:</span><span class="n">value</span><span class="p">];</span>
<span class="p">}]</span> <span class="nl">deliverOn</span><span class="p">:[</span><span class="n">RACScheduler</span> <span class="n">mainThreadScheduler</span><span class="p">]]</span> <span class="nl">map</span><span class="p">:</span><span class="o">^</span><span class="kt">id</span><span class="p">(</span><span class="bp">NSData</span> <span class="o">*</span><span class="n">data</span><span class="p">){</span>
    <span class="k">return</span> <span class="p">[</span><span class="bp">UIImage</span> <span class="nl">imageWithData</span><span class="p">:</span><span class="n">data</span><span class="p">];</span>
<span class="p">}];</span>
</code></pre></div>
<p>I finally landed a way to asynchronously load images to populate tableview cells, but I&#39;m not settling on this solution because <code>+[UIImage imageWithData]</code> can be slow.</p>

<h3>Attempt N</h3>

<p>In my efforts to find the Holy Grail of how to go about asycnrhonously loading images using Reactive Cocoa, I stumbled across a very interesting <a href="https://github.com/ReactiveCocoa/ReactiveViewModel/issues/16">GitHub issue</a>.² The gentleman in this thread appears to have a working solution using <code>+[NSURLConnection rac_sendAsynchronousRequest:]</code>, but is struggling with a higher level problem. Ash Furrow chimed in on the thread referencing an <a href="https://github.com/ashfurrow/FunctionalReactivePixels/issues/27">issue</a> from his project to see a different solution.³ The code in their dicsussion started out like this:</p>
<div class="highlight"><pre><code class="language-objective-c" data-lang="objective-c"><span class="n">RAC</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="n">imageView</span><span class="p">,</span> <span class="n">image</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[[</span><span class="n">RACObserve</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="n">photoModel</span><span class="p">.</span><span class="n">thumbnailData</span><span class="p">)</span> <span class="nl">ignore</span><span class="p">:</span><span class="nb">nil</span><span class="p">]</span> <span class="nl">map</span><span class="p">:</span><span class="o">^</span><span class="kt">id</span><span class="p">(</span><span class="kt">id</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">RACSignal</span> <span class="nl">createSignal</span><span class="p">:</span><span class="o">^</span><span class="n">RACDisposable</span> <span class="o">*</span><span class="p">(</span><span class="kt">id</span><span class="o">&lt;</span><span class="n">RACSubscriber</span><span class="o">&gt;</span> <span class="n">subscriber</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">[[</span><span class="n">RACScheduler</span> <span class="nl">schedulerWithPriority</span><span class="p">:</span><span class="n">RACSchedulerPriorityHigh</span><span class="p">]</span> <span class="nl">schedule</span><span class="p">:</span><span class="o">^</span><span class="p">{</span>
            <span class="p">[</span><span class="n">value</span> <span class="nl">af_decompressedImageFromJPEGDataWithCallback</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="bp">UIImage</span> <span class="o">*</span><span class="n">decompressedImage</span><span class="p">)</span> <span class="p">{</span>
                 <span class="p">[</span><span class="n">subscriber</span> <span class="nl">sendNext</span><span class="p">:</span><span class="n">decompressedImage</span><span class="p">];</span>
                 <span class="p">[</span><span class="n">subscriber</span> <span class="n">sendCompleted</span><span class="p">];</span>
             <span class="p">}];</span>
        <span class="p">}];</span>
        <span class="k">return</span> <span class="nb">nil</span><span class="p">;</span>
    <span class="p">}];</span>
<span class="p">}]</span> <span class="n">switchToLatest</span><span class="p">];</span>
</code></pre></div>
<p>What&#39;s interesting is that they are creating and returning a signal within their <code>map:</code> block, as opposed to decompressing on the main thread and returning a value object. It makes me wonder why the examples I&#39;ve seen didn&#39;t have to do that, and simply chaining it with <code>reduceEach:</code> was good enough.</p>

<p>When discussing cancelling the background operation, <a href="https://github.com/kastiglione">Dave Lee</a> chimed in, &quot;You could use <code>-subscribeOn:</code> which also takes care of handling cancelation. Even if you don&#39;t, since <code>-schedule:</code> returns a disposable, which can be returned as the result of <code>+createSignal:</code>.&quot;</p>
<div class="highlight"><pre><code class="language-objective-c" data-lang="objective-c">    <span class="n">RAC</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="n">imageView</span><span class="p">,</span> <span class="n">image</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[[</span><span class="n">RACObserve</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="n">photoModel</span><span class="p">.</span><span class="n">thumbnailData</span><span class="p">)</span> <span class="nl">ignore</span><span class="p">:</span><span class="nb">nil</span><span class="p">]</span> <span class="nl">map</span><span class="p">:</span><span class="o">^</span><span class="kt">id</span><span class="p">(</span><span class="kt">id</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">[[</span><span class="n">RACSignal</span> <span class="nl">createSignal</span><span class="p">:</span><span class="o">^</span><span class="n">RACDisposable</span> <span class="o">*</span><span class="p">(</span><span class="kt">id</span><span class="o">&lt;</span><span class="n">RACSubscriber</span><span class="o">&gt;</span> <span class="n">subscriber</span><span class="p">)</span> <span class="p">{</span>
            <span class="p">[</span><span class="n">value</span> <span class="nl">af_decompressedImageFromJPEGDataWithCallback</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="bp">UIImage</span> <span class="o">*</span><span class="n">decompressedImage</span><span class="p">)</span> <span class="p">{</span>
                 <span class="p">[</span><span class="n">subscriber</span> <span class="nl">sendNext</span><span class="p">:</span><span class="n">decompressedImage</span><span class="p">];</span>
                 <span class="p">[</span><span class="n">subscriber</span> <span class="n">sendCompleted</span><span class="p">];</span>
             <span class="p">}];</span>
            <span class="k">return</span> <span class="nb">nil</span><span class="p">;</span>
        <span class="p">}]</span> <span class="nl">subscribeOn</span><span class="p">:[</span><span class="n">RACScheduler</span> <span class="n">scheduler</span><span class="p">]];</span>
    <span class="p">}]</span> <span class="n">switchToLatest</span><span class="p">];</span>
</code></pre></div>
<p><code>switchToLatest</code> is new to me, and a quick look at the docs says that it &quot;Returns a signal which passes through <code>next</code>s and <code>error</code>s from the latest signal sent by the receiver, and sends <code>completed</code> when both the receiver and the last sent signal complete.&quot; My best guess is since the subscriber of the image is now subscribing to a signal-returning-a-signal, the <code>switchToLatest</code> will ensure that the original subscriber will be sent the <code>next</code> event which will contain a value object: the decompressed <code>UIImage</code>.</p>

<h3>Conclusion</h3>

<p>I never did return to this problem, and left the slower implementation in the code. There are bigger things ahead, and I don&#39;t want this one to slow me down any more. If anyone reading this can steer me in the right direction, I&#39;d appreciate it!</p>

<h3>References</h3>

<ul>
<li><a href="https://github.com/ashfurrow/FunctionalReactivePixels/blob/aef9b670ec5f14d496049c9e214f99513ca579df/FRP/FRPPhotoImporter.m#L46-L58">[1] Functional Reactive Pixels - FRPPhotoImporter.m:L46-58</a></li>
<li><a href="https://github.com/ReactiveCocoa/ReactiveViewModel/issues/16">[2] Binding asynchronously loaded images from a view-model</a></li>
<li><a href="https://github.com/ashfurrow/FunctionalReactivePixels/issues/27">[3] Bad scrolling performance</a></li>
</ul>

          <div class="meta">
            <p class="date-publish">
              Published:
              <date class="date-pub" title="2015-01-07T00:00:00-06:00" datetime="2015-01-07T00:00:00-06:00" pubdate>
              <span class="month"><abbr>January</abbr></span>
              <span class="day">07</span>
              <span class="year">2015</span>
              </date>
            </p>
          </div><!-- meta -->
          
          <div class="comments">
            
            <div id="disqus_thread"></div>
            <script type="text/javascript">
                /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
                var disqus_shortname = 'marksandsgithub'; // required: replace example with your forum shortname

                /* * * DON'T EDIT BELOW THIS LINE * * */
                (function() {
                    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
                })();
            </script>
            <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
            <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
            
          </div><!-- comments -->
        </div><!-- entry-content -->
      </div><!-- bd -->
      <footer class="unit-foot">
        <div class="unit-inner unit-foot-inner">
          <nav class="pagination">
            <ul>
              
              <li class="prev"><a class="internal" rel="prev"  href="/2015/1/2/reacting-to-reactive-cocoa-part-ii.html" title="View Reacting to Reactive Cocoa Part II">&laquo; Reacting to Reactive Cocoa Part II</a></li>
              
              
              
            </ul>
          </nav>
      </footer>

    </div><!-- content -->
  </div><!-- unit-inner -->
</article>

              </div>
            </div><!-- unit-inner -->
          </div><!-- unit-body -->
        </div><!-- body -->

      </div><!-- page -->

		<script>
			/*! A fix for the iOS orientationchange zoom bug.Script by @scottjehl, rebound by @wilto. MIT License.*/
			(function(j){var i=j.document;if(!i.querySelectorAll){return}var l=i.querySelectorAll("meta[name=viewport]")[0],a=l&&l.getAttribute("content"),h=a+", maximum-scale=1.0",d=a+", maximum-scale=10.0",g=true,c=j.orientation,k=0;if(!l){return}function f(){l.setAttribute("content",d);g=true}function b(){l.setAttribute("content",h);g=false}function e(m){c=Math.abs(j.orientation);k=Math.abs(m.gamma);if(k>8&&c===0){if(g){b()}}else{if(!g){f()}}}j.addEventListener("orientationchange",f,false);j.addEventListener("deviceorientation",e,false)})(this);
		</script>
      
		<script>
			(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

			ga('create', 'UA-41405801-1', 'marksands.github.io');
			ga('send', 'pageview');
		</script>

		<script type="text/javascript">var _kmq = _kmq || [];
			var _kmk = _kmk || '61c42d0613ba9e478d7963a3e2e30d87c185d1bf';
			function _kms(u){
			  setTimeout(function(){
			    var d = document, f = d.getElementsByTagName('script')[0],
			    s = d.createElement('script');
			    s.type = 'text/javascript'; s.async = true; s.src = u;
			    f.parentNode.insertBefore(s, f);
			  }, 1);
			}
			_kms('//i.kissmetrics.com/i.js');
			_kms('//doug1izaerwt3.cloudfront.net/' + _kmk + '.1.js');
		</script>

    </body>
</html>
