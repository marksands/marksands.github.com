<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Better Codable Through Property Wrappers</title>
  <meta name="description" content="With the introduction of Codable in Swift 4, working with JSON has never been more pleasant. Until it‚Äôs not. Codable definitely has its warts, and often the ...">

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="http://localhost:4000/2019/10/21/better-codable-through-property-wrappers.html">
  <link rel="alternate" type="application/rss+xml" title="Mark Sands" href="/feed.xml">
  
  
</head>


  <body>

    <header class="site-header" role="banner">

  <div class="wrapper">

    <a class="site-title" href="/">Mark Sands</a>

    <nav class="site-nav">
      <span class="menu-icon">
        <svg viewBox="0 0 18 15" width="18px" height="15px">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </span>

      <div class="trigger">
        
          
          <a class="page-link" href="/about/">About</a>
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
      </div>
    </nav>

  </div>

</header>

    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Better Codable Through Property Wrappers</h1>
    <p class="post-meta">
      <time datetime="2019-10-21T00:00:00-05:00" itemprop="datePublished">
        
        Oct 21, 2019
      </time>
      </p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>With the introduction of Codable in Swift 4, working with JSON has never been more pleasant. Until it‚Äôs not. Codable definitely has its warts, and often the pain is introduced by suffering through boilerplate of implementing custom Decodable initializers.</p>

<p>Fortunately, Swift 5.1 introduced a feature known as property wrappers that can take all of that boilerplate away. While it doesn‚Äôt magically solve every painpoint with Codable, it definitely makes working with it much more pleasant. To that end, I‚Äôve been accumulating my own wrappers on my GitHub at <a href="https://github.com/marksands/BetterCodable">github.com/marksands/BetterCodable</a>. Keep reading for a deep dive into their implementation and what it has to offer.</p>

<!-- more -->

<p>Recently I found myself working with an API that returned user objects. Except that many of the user objects had null data, so our struct initially looked like this:</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">User</span><span class="p">:</span> <span class="kt">Codable</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">firstName</span><span class="p">:</span> <span class="kt">String</span><span class="p">?</span>
    <span class="k">var</span> <span class="nv">surname</span><span class="p">:</span> <span class="kt">String</span><span class="p">?</span>
    <span class="k">var</span> <span class="nv">jobTitle</span><span class="p">:</span> <span class="kt">String</span><span class="p">?</span>
    <span class="k">var</span> <span class="nv">email</span><span class="p">:</span> <span class="kt">String</span><span class="p">?</span>
<span class="p">}</span>

<span class="kd">struct</span> <span class="kt">UserResponse</span><span class="p">:</span> <span class="kt">Codable</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">users</span><span class="p">:</span> <span class="p">[</span><span class="kt">User</span><span class="p">]</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Needless to say, making every field an optional type was painful. One solution to the null data is to provide sensible defaults at the cost of implementing a custom Decodable initializer. But ideally, we really just don‚Äôt want Users that don‚Äôt satisfy valid data for all fields. Now we‚Äôre left at a crossroad because we need the ability to decode an array of Users that might contain bad data yet discard the bad users. What we‚Äôre looking for is essentially the Codable version of <code class="highlighter-rouge">arrayOfUses.compactMap { $0 }</code>, to filter out nils.</p>

<p>There are a few hurdles to overcome for this seemingly simple task. If the goal is to keep all fields non-optional, then we need to implement a custom initializer on the <code class="highlighter-rouge">UserResponse</code> type. When decoding a User value, if a non-optional field is found to be null, then an exception is thrown and the <em>entire</em> UserResponse fails to decode. In order to ignore or filter out failed User elements, we have to go really into the weeds with Codable.</p>

<h2 id="decoding-the-array">Decoding the Array</h2>

<p>First, we have to use an <code class="highlighter-rouge">unkeyedContainer()</code>, since we are decoding is a container of user values. This returns a container that conforms to <code class="highlighter-rouge">UnkeyedDecodingContainer</code>, which has a helpful property <code class="highlighter-rouge">isAtEnd</code> which indicates if the container has any further elements to decode. Once we iterate over the elements in the container, and decode them, ignoring failed User decodings, we set the users array to our intermediate elements array.</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">UserResponse</span><span class="p">:</span> <span class="kt">Codable</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">users</span><span class="p">:</span> <span class="p">[</span><span class="kt">User</span><span class="p">]</span>
    
    <span class="nf">init</span><span class="p">(</span><span class="n">from</span> <span class="nv">decoder</span><span class="p">:</span> <span class="kt">Decoder</span><span class="p">)</span> <span class="k">throws</span> <span class="p">{</span>
        <span class="k">var</span> <span class="nv">container</span> <span class="o">=</span> <span class="k">try</span> <span class="n">decoder</span><span class="o">.</span><span class="nf">unkeyedContainer</span><span class="p">()</span>
        <span class="k">var</span> <span class="nv">elements</span><span class="p">:</span> <span class="p">[</span><span class="kt">User</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="o">!</span><span class="n">container</span><span class="o">.</span><span class="n">isAtEnd</span> <span class="p">{</span>
            <span class="o">...</span>
        <span class="p">}</span>
        
        <span class="n">users</span> <span class="o">=</span> <span class="n">elements</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Ignoring the erroneously decoded values is the interesting portion. If decoding a user fails, an exception is thrown, which we wrap in a do/catch statement so that decoding the remainder of the container is not in vain. Since the User failed to decode, we still need the container to progress beyond that value, however.</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code>    <span class="k">do</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">value</span> <span class="o">=</span> <span class="k">try</span> <span class="n">container</span><span class="o">.</span><span class="nf">decode</span><span class="p">(</span><span class="kt">User</span><span class="o">.</span><span class="k">self</span><span class="p">)</span>
        <span class="n">elements</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">catch</span> <span class="p">{</span>
        <span class="n">_</span> <span class="o">=</span> <span class="k">try</span><span class="p">?</span> <span class="n">container</span><span class="o">.</span><span class="nf">decode</span><span class="p">(???)</span>
    <span class="p">}</span>
</code></pre>
</div>

<p>The solution is rather clever. We simply need the container to decode <em>something</em>, so all it needs to know is that we have a Decodable type.</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code>    <span class="kd">private</span> <span class="kd">struct</span> <span class="kt">AnyDecodableValue</span><span class="p">:</span> <span class="kt">Decodable</span> <span class="p">{}</span>
    <span class="o">...</span>
    <span class="k">do</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">value</span> <span class="o">=</span> <span class="k">try</span> <span class="n">container</span><span class="o">.</span><span class="nf">decode</span><span class="p">(</span><span class="kt">User</span><span class="o">.</span><span class="k">self</span><span class="p">)</span>
        <span class="n">elements</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">catch</span> <span class="p">{</span>
        <span class="n">_</span> <span class="o">=</span> <span class="k">try</span><span class="p">?</span> <span class="n">container</span><span class="o">.</span><span class="nf">decode</span><span class="p">(</span><span class="kt">AnyDecodableValue</span><span class="o">.</span><span class="k">self</span><span class="p">)</span>
    <span class="p">}</span>
</code></pre>
</div>

<p><code class="highlighter-rouge">AnyDecodableValue</code> is enough to allow the container to progress beyond this element and continue decoding the remainder of the users. Now that we know how to make a lossy decodable array, all that‚Äôs left to do is genericize it and wrap it behind a property wrapper type for maximum reusability (and way less code). See <a href="https://docs.swift.org/swift-book/LanguageGuide/Properties.html#ID617">Apple‚Äôs swift documentation</a> for the real meat on implementing property wrappers.</p>

<p>Turning our solution into a generic property wrapper isn‚Äôt too much additional work. Here‚Äôs the final form.</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="c1">// Property wrappers require this annotation at the top level of the type</span>
<span class="kd">@propertyWrapper</span>
<span class="kd">public</span> <span class="kd">struct</span> <span class="kt">LossyArray</span><span class="o">&lt;</span><span class="kt">T</span><span class="p">:</span> <span class="kt">Codable</span><span class="o">&gt;</span><span class="p">:</span> <span class="kt">Codable</span> <span class="p">{</span>
    <span class="c1">// we previously saw the AnyDecodableValue technique</span>
    <span class="kd">private</span> <span class="kd">struct</span> <span class="kt">AnyDecodableValue</span><span class="p">:</span> <span class="kt">Codable</span> <span class="p">{}</span>

    <span class="c1">// LossyDecodableValue is a single value of a generic type that we attempt to decode</span>
    <span class="kd">private</span> <span class="kd">struct</span> <span class="kt">LossyDecodableValue</span><span class="o">&lt;</span><span class="kt">Value</span><span class="p">:</span> <span class="kt">Codable</span><span class="o">&gt;</span><span class="p">:</span> <span class="kt">Codable</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Value</span>
        
        <span class="kd">public</span> <span class="nf">init</span><span class="p">(</span><span class="n">from</span> <span class="nv">decoder</span><span class="p">:</span> <span class="kt">Decoder</span><span class="p">)</span> <span class="k">throws</span> <span class="p">{</span>
            <span class="k">let</span> <span class="nv">container</span> <span class="o">=</span> <span class="k">try</span> <span class="n">decoder</span><span class="o">.</span><span class="nf">singleValueContainer</span><span class="p">()</span>
            <span class="n">value</span> <span class="o">=</span> <span class="k">try</span> <span class="n">container</span><span class="o">.</span><span class="nf">decode</span><span class="p">(</span><span class="kt">Value</span><span class="o">.</span><span class="k">self</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="c1">// every property wrapper requires a wrappedValue</span>
    <span class="kd">public</span> <span class="k">var</span> <span class="nv">wrappedValue</span><span class="p">:</span> <span class="p">[</span><span class="kt">T</span><span class="p">]</span>
    
    <span class="kd">public</span> <span class="nf">init</span><span class="p">(</span><span class="nv">wrappedValue</span><span class="p">:</span> <span class="p">[</span><span class="kt">T</span><span class="p">])</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">wrappedValue</span> <span class="o">=</span> <span class="n">wrappedValue</span>
    <span class="p">}</span>
    
    <span class="kd">public</span> <span class="nf">init</span><span class="p">(</span><span class="n">from</span> <span class="nv">decoder</span><span class="p">:</span> <span class="kt">Decoder</span><span class="p">)</span> <span class="k">throws</span> <span class="p">{</span>
        <span class="k">var</span> <span class="nv">container</span> <span class="o">=</span> <span class="k">try</span> <span class="n">decoder</span><span class="o">.</span><span class="nf">unkeyedContainer</span><span class="p">()</span>
        
        <span class="k">var</span> <span class="nv">elements</span><span class="p">:</span> <span class="p">[</span><span class="kt">T</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="c1">// continue decoding until we get to the last element</span>
        <span class="k">while</span> <span class="o">!</span><span class="n">container</span><span class="o">.</span><span class="n">isAtEnd</span> <span class="p">{</span>
            <span class="k">do</span> <span class="p">{</span>
                <span class="c1">// try to decode an arbitrary value of our generic type T</span>
                <span class="k">let</span> <span class="nv">value</span> <span class="o">=</span> <span class="k">try</span> <span class="n">container</span><span class="o">.</span><span class="nf">decode</span><span class="p">(</span><span class="kt">LossyDecodableValue</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;.</span><span class="k">self</span><span class="p">)</span><span class="o">.</span><span class="n">value</span>
                <span class="n">elements</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="p">}</span> <span class="k">catch</span> <span class="p">{</span>
                <span class="c1">// if that fails, no sweat‚Äîwe still need to move our decoding cursor past that element</span>
                <span class="n">_</span> <span class="o">=</span> <span class="k">try</span><span class="p">?</span> <span class="n">container</span><span class="o">.</span><span class="nf">decode</span><span class="p">(</span><span class="kt">AnyDecodableValue</span><span class="o">.</span><span class="k">self</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>
        
        <span class="c1">// and finally we store our elements</span>
        <span class="k">self</span><span class="o">.</span><span class="n">wrappedValue</span> <span class="o">=</span> <span class="n">elements</span>
    <span class="p">}</span>
    
    <span class="kd">public</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">to</span> <span class="nv">encoder</span><span class="p">:</span> <span class="kt">Encoder</span><span class="p">)</span> <span class="k">throws</span> <span class="p">{</span>
        <span class="k">try</span> <span class="n">wrappedValue</span><span class="o">.</span><span class="nf">encode</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="n">encoder</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Our initial obstacle was overcome with our journey to property wrappers. Take a look at the simplified, final solution that gets us exactly what we want: a non-optional array of users with nothing but valid fields.</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">User</span><span class="p">:</span> <span class="kt">Codable</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">firstName</span><span class="p">:</span> <span class="kt">String</span>
    <span class="k">var</span> <span class="nv">surname</span><span class="p">:</span> <span class="kt">String</span>
    <span class="k">var</span> <span class="nv">jobTitle</span><span class="p">:</span> <span class="kt">String</span>
    <span class="k">var</span> <span class="nv">email</span><span class="p">:</span> <span class="kt">String</span>
<span class="p">}</span>

<span class="kd">struct</span> <span class="kt">UserResponse</span><span class="p">:</span> <span class="kt">Codable</span> <span class="p">{</span>
    <span class="kd">@LossyArray</span> <span class="k">var</span> <span class="nv">users</span><span class="p">:</span> <span class="p">[</span><span class="kt">User</span><span class="p">]</span>
<span class="p">}</span>
</code></pre>
</div>

<h2 id="lossydictionary">LossyDictionary</h2>

<p>I took a similar approach with Dictionaries and created a <code class="highlighter-rouge">@LossyDictionary</code> property wrapper. It decodes Dictionaries and filters invalid key-value pairs if the decoder is unable to decode the value. I won‚Äôt go into the weeds with this one, but I encourage the reader to take a look at the source for curiosity‚Äôs sake. Shout out to the Swift source code for basically telling me verbatim how they decode Dictionaries‚Äîbig help that open source code.</p>

<p>As an example, here‚Äôs <code class="highlighter-rouge">@LossyDictionary</code> in practice.</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">Response</span><span class="p">:</span> <span class="kt">Codable</span> <span class="p">{</span>
    <span class="kd">@LossyDictionary</span> <span class="k">var</span> <span class="nv">values</span><span class="p">:</span> <span class="p">[</span><span class="kt">String</span><span class="p">:</span> <span class="kt">String</span><span class="p">]</span>
<span class="p">}</span>

<span class="k">let</span> <span class="nv">json</span> <span class="o">=</span> <span class="err">#</span><span class="s">"{ "</span><span class="n">values</span><span class="s">": {"</span><span class="n">a</span><span class="s">": "</span><span class="kt">A</span><span class="s">", "</span><span class="n">b</span><span class="s">": "</span><span class="kt">B</span><span class="s">", "</span><span class="n">c</span><span class="s">": null } }"</span><span class="err">#</span><span class="o">.</span><span class="nf">data</span><span class="p">(</span><span class="nv">using</span><span class="p">:</span> <span class="o">.</span><span class="n">utf8</span><span class="p">)</span><span class="o">!</span>
<span class="k">let</span> <span class="nv">result</span> <span class="o">=</span> <span class="k">try</span> <span class="kt">JSONDecoder</span><span class="p">()</span><span class="o">.</span><span class="nf">decode</span><span class="p">(</span><span class="kt">Response</span><span class="o">.</span><span class="k">self</span><span class="p">,</span> <span class="nv">from</span><span class="p">:</span> <span class="n">json</span><span class="p">)</span>

<span class="nf">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="c1">// ["a": "A", "b": "B"]</span>
</code></pre>
</div>

<h2 id="default-and-friends">Default and Friends</h2>

<p>Creating a property wrapper to assign a sensible default for a Codable property just isn‚Äôt possible in Swift 5.1. In the meantime, I‚Äôve created a few helpers that one may find useful.</p>

<p>Optional Bools are weird. A type that once meant true or false, now has three possible states: <code class="highlighter-rouge">.some(true)</code>, <code class="highlighter-rouge">.some(false)</code>, or <code class="highlighter-rouge">.none</code>. And the .none condition could indicate truthiness if BadDecisions‚Ñ¢ were made. The weirdness of Optional Booleans extends to other types, such as Arrays. Soroush Khanlou has a <a href="http://khanlou.com/2016/10/emptiness/">great blog post</a> explaining why you may want to avoid Optional Arrays.</p>

<p>Unfortunately, this idea doesn‚Äôt come for free in Swift out of the box. Being forced to implement a custom initializer in order to nil coalesce nil booleans or nil arrays is no fun. That‚Äôs why I added a few sane property wrappers that help provide sensible defaults for these disastrous situations.</p>

<h4 id="defaultfalse">@DefaultFalse</h4>

<p>This does what it says on the box. It will ensure your nullable bool is set to <code class="highlighter-rouge">false</code> if the API insists on it being nil. The implementation isn‚Äôt interesting but here‚Äôs an example use case.</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">UserPrivilege</span><span class="p">:</span> <span class="kt">Codable</span> <span class="p">{</span>
    <span class="kd">@DefaultFalse</span> <span class="k">var</span> <span class="nv">isAdmin</span><span class="p">:</span> <span class="kt">Bool</span>
<span class="p">}</span>

<span class="k">let</span> <span class="nv">json</span> <span class="o">=</span> <span class="err">#</span><span class="s">"{ "</span><span class="n">isAdmin</span><span class="s">": null }"</span><span class="err">#</span><span class="o">.</span><span class="nf">data</span><span class="p">(</span><span class="nv">using</span><span class="p">:</span> <span class="o">.</span><span class="n">utf8</span><span class="p">)</span><span class="o">!</span>
<span class="k">let</span> <span class="nv">result</span> <span class="o">=</span> <span class="k">try</span> <span class="kt">JSONDecoder</span><span class="p">()</span><span class="o">.</span><span class="nf">decode</span><span class="p">(</span><span class="kt">Response</span><span class="o">.</span><span class="k">self</span><span class="p">,</span> <span class="nv">from</span><span class="p">:</span> <span class="n">json</span><span class="p">)</span>

<span class="nf">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="c1">// UserPrivilege(isAdmin: false)</span>
</code></pre>
</div>

<h4 id="defaultemptyarray">@DefaultEmptyArray</h4>

<p>This will take your once-nullable container and leave you with an empty array upon decoding. Imagine a person with a collection of friends, or an album with a collection of reviews, or a pizza with a collection of toppings. Expressing emptiness, rather than missing, for these types, can do a lot for clarity. Here‚Äôs an example usage.</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">Response</span><span class="p">:</span> <span class="kt">Codable</span> <span class="p">{</span>
    <span class="kd">@DefaultEmptyArray</span> <span class="k">var</span> <span class="nv">favorites</span><span class="p">:</span> <span class="p">[</span><span class="kt">Favorite</span><span class="p">]</span>
<span class="p">}</span>

<span class="k">let</span> <span class="nv">json</span> <span class="o">=</span> <span class="err">#</span><span class="s">"{ "</span><span class="n">favorites</span><span class="s">": null }"</span><span class="err">#</span><span class="o">.</span><span class="nf">data</span><span class="p">(</span><span class="nv">using</span><span class="p">:</span> <span class="o">.</span><span class="n">utf8</span><span class="p">)</span><span class="o">!</span>
<span class="k">let</span> <span class="nv">result</span> <span class="o">=</span> <span class="k">try</span> <span class="kt">JSONDecoder</span><span class="p">()</span><span class="o">.</span><span class="nf">decode</span><span class="p">(</span><span class="kt">Response</span><span class="o">.</span><span class="k">self</span><span class="p">,</span> <span class="nv">from</span><span class="p">:</span> <span class="n">json</span><span class="p">)</span>

<span class="nf">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="c1">// Response(favorites: [])</span>
</code></pre>
</div>

<p>An astute reader might observe that <code class="highlighter-rouge">@LossyArray</code> will produce the same result, but not without the unintended side effects of losing elements due to silent failures.</p>

<h4 id="defaultemptydictionary">@DefaultEmptyDictionary</h4>

<p>As mentioned previously, Optional Dictionaries are yet another container where nil and emptiness collide. This property wrapper decodes dictionaries and returns an empty dictionary instead of nil if the decoder is unable to decode the container. Here‚Äôs an example usage:</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">Response</span><span class="p">:</span> <span class="kt">Codable</span> <span class="p">{</span>
    <span class="kd">@DefaultEmptyDictionary</span> <span class="k">var</span> <span class="nv">scores</span><span class="p">:</span> <span class="p">[</span><span class="kt">String</span><span class="p">:</span> <span class="kt">Int</span><span class="p">]</span>
<span class="p">}</span>

<span class="k">let</span> <span class="nv">json</span> <span class="o">=</span> <span class="err">#</span><span class="s">"{ "</span><span class="n">scores</span><span class="s">": null }"</span><span class="err">#</span><span class="o">.</span><span class="nf">data</span><span class="p">(</span><span class="nv">using</span><span class="p">:</span> <span class="o">.</span><span class="n">utf8</span><span class="p">)</span><span class="o">!</span>
<span class="k">let</span> <span class="nv">result</span> <span class="o">=</span> <span class="k">try</span> <span class="kt">JSONDecoder</span><span class="p">()</span><span class="o">.</span><span class="nf">decode</span><span class="p">(</span><span class="kt">Response</span><span class="o">.</span><span class="k">self</span><span class="p">,</span> <span class="nv">from</span><span class="p">:</span> <span class="n">json</span><span class="p">)</span>

<span class="nf">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="c1">// Response(values: [:])</span>
</code></pre>
</div>

<h2 id="losslessvalue">@LosslessValue</h2>

<p>All code and credit for this goes to <a href="https://twitter.com/iankay">Ian Keen</a>.</p>

<p>Somtimes APIs can be unpredictable. They may treat some form of Identifiers or SKUs as <code class="highlighter-rouge">Int</code>s for one response and <code class="highlighter-rouge">String</code>s for another. Or you might find yourself encountering <code class="highlighter-rouge">"true"</code> when you expect a boolean. This is where <code class="highlighter-rouge">@LosslessValue</code> comes into play. It will attempt to decode a value into the type that you expect, preserving the data that would otherwise throw an exception or be lost altogether.</p>

<p>I would love to dive into the source details of this wrapper, but this alone probably deserves its own post. It‚Äôs rather dense and complex compared to the other wrappers. For the curious, <a href="https://github.com/marksands/BetterCodable/blob/99378904e47bc582acc45fd85ec738c24f61de30/Sources/BetterCodable/LosslessValue.swift">take a look at the source</a> to see the machinery under the hood.</p>

<p>As an example, suppose you have a Product type that has a sku and an availability flag. Due to microservices, your backend team has waffled over whether or not the sku should be a string or an int, and the availability flag can be null because reasons. This might be one solution in this entirely hypothetical scenario.</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">Product</span><span class="p">:</span> <span class="kt">Codable</span> <span class="p">{</span>
    <span class="kd">@LosslessValue</span> <span class="k">var</span> <span class="nv">sku</span><span class="p">:</span> <span class="kt">String</span>
    <span class="kd">@LosslessValue</span> <span class="k">var</span> <span class="nv">isAvailable</span><span class="p">:</span> <span class="kt">Bool</span>
<span class="p">}</span>

<span class="k">let</span> <span class="nv">json</span> <span class="o">=</span> <span class="err">#</span><span class="s">"{ "</span><span class="n">sku</span><span class="s">": 12345, "</span><span class="n">isAvailable</span><span class="s">": "</span><span class="kc">true</span><span class="s">" }"</span><span class="err">#</span><span class="o">.</span><span class="nf">data</span><span class="p">(</span><span class="nv">using</span><span class="p">:</span> <span class="o">.</span><span class="n">utf8</span><span class="p">)</span><span class="o">!</span>
<span class="k">let</span> <span class="nv">result</span> <span class="o">=</span> <span class="k">try</span> <span class="kt">JSONDecoder</span><span class="p">()</span><span class="o">.</span><span class="nf">decode</span><span class="p">(</span><span class="kt">Response</span><span class="o">.</span><span class="k">self</span><span class="p">,</span> <span class="nv">from</span><span class="p">:</span> <span class="n">json</span><span class="p">)</span>

<span class="nf">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="c1">// Response(sku: "12355", isAvailable: true)</span>
</code></pre>
</div>

<h2 id="date-wrappers">Date Wrappers</h2>

<p>One common frustration with <code class="highlighter-rouge">Codable</code> is decoding entities that have mixed date formats. <code class="highlighter-rouge">JSONDecoder</code> comes built in with a handy <code class="highlighter-rouge">dateDecodingStrategy</code> property, but that uses the same date format for all dates that it will decode. And often, <code class="highlighter-rouge">JSONDecoder</code> lives elsewhere from the entity forcing tight coupling with the entities if you choose to use its date decoding strategy.</p>

<p>Property wrappers are a nice solution to the aforementioned issues. It allows tight binding of the date formatting strategy directly with the property of the entity, and allows the <code class="highlighter-rouge">JSONDecoder</code> to remain decoupled from the entities it decodes. Below are a few common Date strategies, but they also serve as a template to implement a custom property wrapper to suit your specific date format needs.</p>

<p>The property wrapper implementation is heavily inspired by <a href="https://twitter.com/iankay">Ian Keen</a>. It uses an internal decodable storage value that tracks the date as well as the original decoded type. The strategy is generic to work against strings or numbers.</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">protocol</span> <span class="kt">DateFormattingCodableStrategy</span> <span class="p">{</span>
    <span class="k">associatedtype</span> <span class="kt">RawValue</span><span class="p">:</span> <span class="kt">Codable</span>

    <span class="kd">static</span> <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">RawValue</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Date</span>
    <span class="kd">static</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">date</span><span class="p">:</span> <span class="kt">Date</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">RawValue</span>
<span class="p">}</span>

<span class="kd">struct</span> <span class="kt">DateCodableValue</span><span class="o">&lt;</span><span class="kt">Formatter</span><span class="p">:</span> <span class="kt">DateFormattingCodableStrategy</span><span class="o">&gt;</span><span class="p">:</span> <span class="kt">Codable</span> <span class="p">{</span>
    <span class="c1">// we store the original value for encoding</span>
    <span class="k">let</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Formatter</span><span class="o">.</span><span class="kt">RawValue</span>
    <span class="k">let</span> <span class="nv">date</span><span class="p">:</span> <span class="kt">Date</span>

    <span class="nf">init</span><span class="p">(</span><span class="nv">date</span><span class="p">:</span> <span class="kt">Date</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">date</span> <span class="o">=</span> <span class="n">date</span>
        <span class="k">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="kt">Formatter</span><span class="o">.</span><span class="nf">encode</span><span class="p">(</span><span class="n">date</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="nf">init</span><span class="p">(</span><span class="n">from</span> <span class="nv">decoder</span><span class="p">:</span> <span class="kt">Decoder</span><span class="p">)</span> <span class="k">throws</span> <span class="p">{</span>
        <span class="c1">// our value is encoded as it otherwise would be from Codable</span>
        <span class="k">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="k">try</span> <span class="kt">Formatter</span><span class="o">.</span><span class="kt">RawValue</span><span class="p">(</span><span class="nv">from</span><span class="p">:</span> <span class="n">decoder</span><span class="p">)</span>
        <span class="c1">// our date is encoded by the custom implementation from our strategy</span>
        <span class="k">self</span><span class="o">.</span><span class="n">date</span> <span class="o">=</span> <span class="k">try</span> <span class="kt">Formatter</span><span class="o">.</span><span class="nf">decode</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">to</span> <span class="nv">encoder</span><span class="p">:</span> <span class="kt">Encoder</span><span class="p">)</span> <span class="k">throws</span> <span class="p">{</span>
        <span class="k">try</span> <span class="n">value</span><span class="o">.</span><span class="nf">encode</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="n">encoder</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Any type that conforms to <code class="highlighter-rouge">DateFormattingCodableStrategy</code> and implements the decode/encode functions can serve as the storage type for the property wrapper. The simplest strategy is the unix timestamp implementation which decodes dates based on a numeric TimeInterval.</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">TimestampDateStrategy</span><span class="p">:</span> <span class="kt">DateFormattingCodableStrategy</span> <span class="p">{</span>
    <span class="kd">static</span> <span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">TimeInterval</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Date</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kt">Date</span><span class="p">(</span><span class="nv">timeIntervalSince1970</span><span class="p">:</span> <span class="n">value</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="kd">static</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">_</span> <span class="nv">date</span><span class="p">:</span> <span class="kt">Date</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">TimeInterval</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">date</span><span class="o">.</span><span class="n">timeIntervalSince1970</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Marrying the storage with the strategy is the recipe needed to produce a desired property wrapper. Sadly this comes with a lot of redundant code across multiple property wrappers that only differ by the strategy type. For anyone reading, <a href="http://twitter.com/marksands">hit me up</a> with improved solutions to this!</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">@propertyWrapper</span>
<span class="kd">public</span> <span class="kd">struct</span> <span class="kt">TimestampDate</span><span class="p">:</span> <span class="kt">Codable</span> <span class="p">{</span>
    <span class="c1">// the engine of our wrapper using the TimestampDateStrategy to relay our date value</span>
    <span class="kd">private</span> <span class="k">var</span> <span class="nv">storage</span><span class="p">:</span> <span class="kt">DateCodableValue</span><span class="o">&lt;</span><span class="kt">TimestampDateStrategy</span><span class="o">&gt;</span>
    
    <span class="kd">public</span> <span class="k">var</span> <span class="nv">wrappedValue</span><span class="p">:</span> <span class="kt">Date</span>
    
    <span class="kd">public</span> <span class="nf">init</span><span class="p">(</span><span class="nv">wrappedValue</span><span class="p">:</span> <span class="kt">Date</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// initialize storage from a date</span>
        <span class="k">self</span><span class="o">.</span><span class="n">storage</span> <span class="o">=</span> <span class="kt">DateCodableValue</span><span class="p">(</span><span class="nv">date</span><span class="p">:</span> <span class="n">wrappedValue</span><span class="p">)</span>
        <span class="k">self</span><span class="o">.</span><span class="n">wrappedValue</span> <span class="o">=</span> <span class="n">storage</span><span class="o">.</span><span class="n">date</span>
    <span class="p">}</span>
    
    <span class="kd">public</span> <span class="nf">init</span><span class="p">(</span><span class="n">from</span> <span class="nv">decoder</span><span class="p">:</span> <span class="kt">Decoder</span><span class="p">)</span> <span class="k">throws</span> <span class="p">{</span>
        <span class="c1">// decode storage from data</span>
        <span class="k">self</span><span class="o">.</span><span class="n">storage</span> <span class="o">=</span> <span class="k">try</span> <span class="kt">DateCodableValue</span><span class="p">(</span><span class="nv">from</span><span class="p">:</span> <span class="n">decoder</span><span class="p">)</span>
        <span class="k">self</span><span class="o">.</span><span class="n">wrappedValue</span> <span class="o">=</span> <span class="n">storage</span><span class="o">.</span><span class="n">date</span>
    <span class="p">}</span>
    
    <span class="kd">public</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">to</span> <span class="nv">encoder</span><span class="p">:</span> <span class="kt">Encoder</span><span class="p">)</span> <span class="k">throws</span> <span class="p">{</span>
        <span class="c1">// encode our original value that's in our storage</span>
        <span class="k">try</span> <span class="k">self</span><span class="o">.</span><span class="n">storage</span><span class="o">.</span><span class="nf">encode</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="n">encoder</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>The nice thing about these property wrappers is the ability to mix multiple date wrappers as needed for a given Codable struct. Without a custom initializer, using the built in date decoding strategy is impossible. The following example throws an exception with the error <strong>‚ÄúExpected date string to be ISO8601-formatted.‚Äù</strong>.</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">Response</span><span class="p">:</span> <span class="kt">Codable</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">createdAt</span><span class="p">:</span> <span class="kt">Date</span> <span class="c1">// ISO8601</span>
    <span class="k">var</span> <span class="nv">birthday</span><span class="p">:</span> <span class="kt">Date</span> <span class="c1">// y-MM-dd</span>
<span class="p">}</span>

<span class="k">let</span> <span class="nv">json</span> <span class="o">=</span> <span class="err">#</span><span class="s">"{ "</span><span class="n">createdAt</span><span class="s">": "</span><span class="mi">2019</span><span class="o">-</span><span class="mi">10</span><span class="o">-</span><span class="mi">19</span><span class="kt">T16</span><span class="p">:</span><span class="mi">14</span><span class="p">:</span><span class="mi">32</span><span class="o">-</span><span class="mo">05</span><span class="p">:</span><span class="mo">00</span><span class="s">", "</span><span class="n">birthday</span><span class="s">": "</span><span class="mi">1984</span><span class="o">-</span><span class="mo">01</span><span class="o">-</span><span class="mi">22</span><span class="s">" }"</span><span class="err">#</span><span class="o">.</span><span class="nf">data</span><span class="p">(</span><span class="nv">using</span><span class="p">:</span> <span class="o">.</span><span class="n">utf8</span><span class="p">)</span><span class="o">!</span>
<span class="k">let</span> <span class="nv">decoder</span> <span class="o">=</span> <span class="kt">JSONDecoder</span><span class="p">()</span>
<span class="n">decoder</span><span class="o">.</span><span class="n">dateDecodingStrategy</span> <span class="o">=</span> <span class="o">.</span><span class="n">iso8601</span> 
<span class="k">let</span> <span class="nv">result</span> <span class="o">=</span> <span class="k">try</span> <span class="n">decoder</span><span class="o">.</span><span class="nf">decode</span><span class="p">(</span><span class="kt">Response</span><span class="o">.</span><span class="k">self</span><span class="p">,</span> <span class="nv">from</span><span class="p">:</span> <span class="n">json</span><span class="p">)</span> <span class="c1">// üí• Error!</span>
</code></pre>
</div>

<p>Our hard work pays off. Multiple date wrappers to the rescue!</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">Response</span><span class="p">:</span> <span class="kt">Codable</span> <span class="p">{</span>
    <span class="kd">@ISO8601Date</span> <span class="k">var</span> <span class="nv">createdAt</span><span class="p">:</span> <span class="kt">Date</span>
    <span class="kd">@YearMonthDayDate</span> <span class="k">var</span> <span class="nv">birthday</span><span class="p">:</span> <span class="kt">Date</span>
<span class="p">}</span>

<span class="k">let</span> <span class="nv">json</span> <span class="o">=</span> <span class="err">#</span><span class="s">"{ "</span><span class="n">createdAt</span><span class="s">": "</span><span class="mi">2019</span><span class="o">-</span><span class="mi">10</span><span class="o">-</span><span class="mi">19</span><span class="kt">T16</span><span class="p">:</span><span class="mi">14</span><span class="p">:</span><span class="mi">32</span><span class="o">-</span><span class="mo">05</span><span class="p">:</span><span class="mo">00</span><span class="s">", "</span><span class="n">birthday</span><span class="s">": "</span><span class="mi">1984</span><span class="o">-</span><span class="mo">01</span><span class="o">-</span><span class="mi">22</span><span class="s">" }"</span><span class="err">#</span><span class="o">.</span><span class="nf">data</span><span class="p">(</span><span class="nv">using</span><span class="p">:</span> <span class="o">.</span><span class="n">utf8</span><span class="p">)</span><span class="o">!</span>
<span class="k">let</span> <span class="nv">decoder</span> <span class="o">=</span> <span class="kt">JSONDecoder</span><span class="p">()</span>
<span class="n">decoder</span><span class="o">.</span><span class="n">dateDecodingStrategy</span> <span class="o">=</span> <span class="o">.</span><span class="n">iso8601</span> 
<span class="k">let</span> <span class="nv">result</span> <span class="o">=</span> <span class="k">try</span> <span class="n">decoder</span><span class="o">.</span><span class="nf">decode</span><span class="p">(</span><span class="kt">Response</span><span class="o">.</span><span class="k">self</span><span class="p">,</span> <span class="nv">from</span><span class="p">:</span> <span class="n">json</span><span class="p">)</span> <span class="c1">// ‚úÖ</span>

<span class="c1">// This produces two valid `Date` values, `createdAt` representing October 19, 2019 and `birthday` January 22nd, 1984.</span>
</code></pre>
</div>

<h2 id="whats-next">What‚Äôs next?</h2>

<p>This has been an experiment in improving life with Codable, and property wrappers just so happens to be the latest trend in achieving that goal. There are many more patterns left to be explored and implemented here, and hopefully this is the inspiration someone needs to keep going down this path.</p>

<ul>
  <li>I have not toyed with property wrapper composition, which might yield even more impressive results.</li>
  <li>I have chosen to limit the number of date strategy wrappers because date formats can be so unwieldy.</li>
  <li>I tried really really hard to make a property wrapper that allows a single property to provide a custom CodingKey, without the enum, but it‚Äôs just not possible. Hopefully future improvements to property wrappers allows possibility.</li>
  <li><a href="http://twitter.com/marksands">Let me know</a> what I should add, what bugs I should fix, or what you‚Äôve created!</li>
</ul>

  </div>

  
    
  
</article>
      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">Mark Sands</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>
            
              Mark Sands
            
            </li>
            
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/marksands"><span class="icon icon--github"><svg viewBox="0 0 16 16" width="16px" height="16px"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">marksands</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/marksands"><span class="icon icon--twitter"><svg viewBox="0 0 16 16" width="16px" height="16px"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">marksands</span></a>

          </li>
          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p></p>
      </div>
    </div>

  </div>

</footer>

  </body>

</html>
